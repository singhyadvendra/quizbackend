-- =========================================================
-- Quiz App Schema (PostgreSQL) - JPA/Hibernate Friendly
-- BIGINT identity keys, VARCHAR enums with CHECK constraints
-- Supports:
--   - Social login identities (Google, LinkedIn)
--   - SINGLE (MCQ) and MULTI (multi-select) questions
--   - Attempts + answers (one row per selected option)
--   - Leaderboards (quiz_id + score + submitted_at)
-- =========================================================

-- -------------------------
-- USERS
-- -------------------------
CREATE TABLE IF NOT EXISTS app_user (
  id           bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  external_id  varchar(100) UNIQUE,         -- optional (e.g., internal auth id)
  full_name    varchar(200),
  email        varchar(200),                -- do NOT require; may be missing
  created_at   timestamptz NOT NULL DEFAULT now()
);

-- Unique email only when present (recommended)
CREATE UNIQUE INDEX IF NOT EXISTS uq_app_user_email_not_null
ON app_user(email)
WHERE email IS NOT NULL;

-- Maps social identities to internal users
CREATE TABLE IF NOT EXISTS user_identity (
  id                bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id            bigint NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,

  provider           varchar(20)  NOT NULL, -- 'google' | 'linkedin'
  provider_subject   varchar(255) NOT NULL, -- OIDC "sub" (stable unique id)

  email              varchar(200),
  email_verified     boolean,
  display_name       varchar(200),
  picture_url        text,

  created_at         timestamptz NOT NULL DEFAULT now(),
  last_login_at      timestamptz,

  CONSTRAINT ck_user_identity_provider
    CHECK (provider IN ('google','linkedin')),

  CONSTRAINT uq_user_identity_provider_sub
    UNIQUE (provider, provider_subject)
);

CREATE INDEX IF NOT EXISTS ix_user_identity_user_id ON user_identity(user_id);

-- -------------------------
-- QUIZ + QUESTION BANK
-- -------------------------
CREATE TABLE IF NOT EXISTS quiz (
  id            bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title         varchar(300) NOT NULL,
  description   text,
  is_active     boolean NOT NULL DEFAULT true,
  created_at    timestamptz NOT NULL DEFAULT now(),
  updated_at    timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS question (
  id              bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  quiz_id          bigint NOT NULL REFERENCES quiz(id) ON DELETE CASCADE,
  question_no      int NOT NULL,                 -- ordering in quiz
  type             varchar(10) NOT NULL,         -- 'SINGLE' | 'MULTI'
  text             text NOT NULL,
  points           numeric(6,2) NOT NULL DEFAULT 1.00,
  is_required      boolean NOT NULL DEFAULT true,
  created_at       timestamptz NOT NULL DEFAULT now(),
  updated_at       timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT uq_question_quiz_no UNIQUE (quiz_id, question_no),
  CONSTRAINT ck_question_no_positive CHECK (question_no > 0),
  CONSTRAINT ck_question_points_nonnegative CHECK (points >= 0),
  CONSTRAINT ck_question_type CHECK (type IN ('SINGLE','MULTI'))
);

CREATE INDEX IF NOT EXISTS ix_question_quiz_id ON question(quiz_id);

-- Options (correct answers stored server-side)
CREATE TABLE IF NOT EXISTS question_option (
  id              bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  question_id     bigint NOT NULL REFERENCES question(id) ON DELETE CASCADE,
  option_no       int NOT NULL,                  -- ordering in question
  text            text NOT NULL,
  is_correct      boolean NOT NULL DEFAULT false,
  created_at      timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT uq_option_question_no UNIQUE (question_id, option_no),
  CONSTRAINT ck_option_no_positive CHECK (option_no > 0),

  -- Needed for composite FK from attempt_answer ensuring option belongs to question
  CONSTRAINT uq_option_question_id_id UNIQUE (question_id, id)
);

CREATE INDEX IF NOT EXISTS ix_option_question_id ON question_option(question_id);

-- -------------------------
-- ATTEMPTS + ANSWERS
-- -------------------------
CREATE TABLE IF NOT EXISTS attempt (
  id             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  quiz_id         bigint NOT NULL REFERENCES quiz(id) ON DELETE CASCADE,
  user_id         bigint REFERENCES app_user(id) ON DELETE SET NULL,

  status          varchar(20) NOT NULL DEFAULT 'IN_PROGRESS', -- IN_PROGRESS|SUBMITTED|ABANDONED
  started_at      timestamptz NOT NULL DEFAULT now(),
  submitted_at    timestamptz,

  -- snapshot scoring fields (recommended)
  score           numeric(10,2),
  total_points    numeric(10,2),

  created_at      timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT ck_attempt_status
    CHECK (status IN ('IN_PROGRESS','SUBMITTED','ABANDONED')),

  CONSTRAINT ck_attempt_submitted_time CHECK (
    (status <> 'SUBMITTED' AND submitted_at IS NULL)
    OR
    (status = 'SUBMITTED' AND submitted_at IS NOT NULL)
  )
);

CREATE INDEX IF NOT EXISTS ix_attempt_quiz_id ON attempt(quiz_id);
CREATE INDEX IF NOT EXISTS ix_attempt_user_id ON attempt(user_id);
CREATE INDEX IF NOT EXISTS ix_attempt_status ON attempt(status);

-- Leaderboard: fast top-N by quiz score, newest first, only submitted attempts
CREATE INDEX IF NOT EXISTS ix_attempt_leaderboard_submitted
ON attempt (quiz_id, score DESC, submitted_at DESC)
WHERE status = 'SUBMITTED';

-- One row per selected option:
--   SINGLE => exactly 1 row for that question (enforce in backend logic)
--   MULTI  => multiple rows for that question
CREATE TABLE IF NOT EXISTS attempt_answer (
  attempt_id     bigint NOT NULL REFERENCES attempt(id) ON DELETE CASCADE,
  question_id    bigint NOT NULL REFERENCES question(id) ON DELETE CASCADE,
  option_id      bigint NOT NULL,
  selected_at    timestamptz NOT NULL DEFAULT now(),

  PRIMARY KEY (attempt_id, question_id, option_id),

  -- enforce option belongs to question
  CONSTRAINT fk_attempt_answer_option_belongs
    FOREIGN KEY (question_id, option_id)
    REFERENCES question_option (question_id, id)
    ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS ix_attempt_answer_attempt_id ON attempt_answer(attempt_id);
CREATE INDEX IF NOT EXISTS ix_attempt_answer_question_id ON attempt_answer(question_id);

-- -------------------------
-- OPTIONAL POLICY INDEXES (enable if you want these behaviors)
-- -------------------------

-- (A) Only one IN_PROGRESS attempt per user per quiz
-- CREATE UNIQUE INDEX uq_attempt_one_in_progress_per_user
-- ON attempt (quiz_id, user_id)
-- WHERE status = 'IN_PROGRESS' AND user_id IS NOT NULL;

-- (B) Only one SUBMITTED attempt per user per quiz
-- CREATE UNIQUE INDEX uq_attempt_one_submitted_per_user
-- ON attempt (quiz_id, user_id)
-- WHERE status = 'SUBMITTED' AND user_id IS NOT NULL;

-- =========================================================
-- Notes:
-- 1) SINGLE vs MULTI selection count is enforced in service logic.
-- 2) Do not return question_option.is_correct to the frontend in real tests.
-- 3) total_points should be set at submit time as snapshot of quiz total.
-- =========================================================
